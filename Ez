-- Speed HUD robusto (funciona via executores como Delta, em PC e mobile)
-- Usa ScreenGui + WorldToViewportPoint para mostrar Nick + "Vel: X" acima do veículo do DRIVER (apenas quem está dirigindo)
-- Tenta ler NumberValue/Attribute com "speed" no modelo do veículo; se não houver, usa velocidade física do seat/HRP.
-- Debug prints no console para diagnosticar problemas de parent/leituras.
-- Instruções: cole e execute este script no seu executor (Delta) enquanto estiver dentro do jogo.

-- Config
local REFRESH_INTERVAL = 0.6       -- checa entrada (dirigindo) a cada X segundos
local UPDATE_GUI_EVERY_FRAME = true
local MAX_VIEW_DISTANCE = 350      -- distância máxima para exibir texto
local NAME_TEXT_SIZE = 20
local SPEED_TEXT_SIZE = 18
local OFFSET_WORLD = Vector3.new(0, 4.2, 0) -- offset acima do veículo/seat
local PRIORITY_SPEED_NAMES = { "Speed", "MaxSpeed", "VehicleSpeed", "CarSpeed", "TopSpeed", "MaxVelocity", "SpeedValue", "DriveSpeed" }

-- Cores
local COLOR_GREEN = Color3.fromRGB(76, 175, 80)
local COLOR_RED   = Color3.fromRGB(244, 67, 54)
local COLOR_WHITE = Color3.fromRGB(255, 255, 255)

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Espera LocalPlayer existir
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	repeat Players.PlayerAdded:Wait() until Players.LocalPlayer
	LocalPlayer = Players.LocalPlayer
end

-- Helpers do executor
local gethui_f = (type(gethui) == "function") and gethui
if not gethui_f and type(syn) == "table" and type(syn.get_hui) == "function" then gethui_f = syn.get_hui end
local protect_gui_f = (type(syn) == "table" and type(syn.protect_gui) == "function") and syn.protect_gui
if not protect_gui_f and type(protect_gui) == "function" then protect_gui_f = protect_gui end

-- Escolhe parent para GUI: PlayerGui > gethui() > CoreGui
local function chooseGuiParent()
	local pg = LocalPlayer:FindFirstChild("PlayerGui")
	if pg and pg.Parent then return pg, "PlayerGui" end
	if gethui_f then
		local ok, gui = pcall(gethui_f)
		if ok and gui then return gui, "gethui()" end
	end
	local ok, cg = pcall(function() return game:GetService("CoreGui") end)
	if ok and cg then return cg, "CoreGui" end
	return nil, "none"
end

local GuiParent, parentSource = chooseGuiParent()
print("[SpeedHUD] GUI parent:", parentSource, GuiParent and GuiParent.ClassName or "nil")
if protect_gui_f and GuiParent then
	pcall(function() protect_gui_f(GuiParent) end)
	print("[SpeedHUD] protect_gui aplicado")
end

if not GuiParent then
	warn("[SpeedHUD] Nenhum GuiParent disponível. Se estiver usando executor no mobile, tente usar gethui() ou um executor que permita GUIs.")
end

-- ScreenGui principal
local screenGui
do
	local ok, sg = pcall(function()
		local s = Instance.new("ScreenGui")
		s.Name = "SpeedHUD_Screen"
		s.ResetOnSpawn = false
		s.Parent = GuiParent
		return s
	end)
	if ok and sg then
		screenGui = sg
	else
		warn("[SpeedHUD] Falha ao criar ScreenGui:", sg)
	end
end

-- Toggle button (simples) - visível localmente
local enabled = true
if screenGui then
	local ok, toggle = pcall(function()
		local sg = Instance.new("ScreenGui")
		sg.Name = "SpeedHUD_Toggle"
		sg.ResetOnSpawn = false
		sg.Parent = GuiParent

		local btn = Instance.new("TextButton")
		btn.Name = "ToggleButton"
		btn.Size = UDim2.new(0, 140, 0, 44)
		btn.Position = UDim2.new(1, -154, 0, 10)
		btn.BackgroundTransparency = 0.25
		btn.BackgroundColor3 = Color3.fromRGB(30,30,30)
		btn.BorderSizePixel = 0
		btn.Font = Enum.Font.SourceSansBold
		btn.TextSize = 18
		btn.TextColor3 = Color3.fromRGB(255,255,255)
		btn.Text = "Speed: ON"
		btn.Parent = sg

		btn.MouseButton1Click:Connect(function()
			enabled = not enabled
			btn.Text = enabled and "Speed: ON" or "Speed: OFF"
			if not enabled then
				for _,v in pairs(guiByPlayer) do
					if v.container then v.container.Visible = false end
				end
			else
				for _,v in pairs(guiByPlayer) do
					if v.container then v.container.Visible = true end
				end
			end
		end)
		return sg
	end)
	if not ok then warn("[SpeedHUD] não foi possível criar toggle:", toggle) end
end

-- Tabelas
guiByPlayer = {} -- player -> { container = Frame, nameLabel = TextLabel, speedLabel = TextLabel, lastVehicle = model/part, lastSeat = seat, speedSource = {type=.., obj=..}, visible = bool, debugShown = bool }

-- Funções de busca de velocidade no veículo
local function findNumberValueSpeed(model)
	if not model then return nil end
	-- procurar nomes prioritários
	for _,n in ipairs(PRIORITY_SPEED_NAMES) do
		local ok, found = pcall(function() return model:FindFirstChild(n, true) end)
		if ok and found and found:IsA("NumberValue") then
			return found
		end
	end
	-- busca por descendentes com "speed" no nome
	for _,desc in ipairs(model:GetDescendants()) do
		if desc:IsA("NumberValue") then
			if string.find(desc.Name:lower(), "speed") then
				return desc
			end
		end
	end
	return nil
end

local function findAttributeSpeed(model)
	if not model or type(model.GetAttributes) ~= "function" then return nil end
	for k,v in pairs(model:GetAttributes()) do
		if type(v) == "number" and string.find(k:lower(), "speed") then
			return k, v
		end
	end
	return nil
end

local function getVehicleFromSeat(seat)
	if not seat then return nil end
	local node = seat
	while node and node ~= Workspace do
		if node:IsA("Model") then return node end
		node = node.Parent
	end
	return nil
end

-- Cria GUI 2D posicionado com WorldToViewportPoint
local function create2DGuiForPlayer(player)
	if not screenGui then return nil end
	-- Reaproveitar se já existe
	if guiByPlayer[player] and guiByPlayer[player].container and guiByPlayer[player].container.Parent then
		return guiByPlayer[player]
	end

	local container = Instance.new("Frame")
	container.Name = "SpeedHUD_" .. tostring(player.UserId or player.Name)
	container.Size = UDim2.new(0, 200, 0, 44)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.ClipsDescendants = false
	container.Parent = screenGui

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextSize = NAME_TEXT_SIZE
	nameLabel.TextScaled = true
	nameLabel.TextColor3 = COLOR_WHITE
	nameLabel.TextStrokeTransparency = 0.75
	nameLabel.Text = player.DisplayName or player.Name
	nameLabel.Parent = container

	local speedLabel = Instance.new("TextLabel")
	speedLabel.Name = "SpeedLabel"
	speedLabel.Size = UDim2.new(1, 0, 0.5, 0)
	speedLabel.Position = UDim2.new(0, 0, 0.5, 0)
	speedLabel.BackgroundTransparency = 1
	speedLabel.Font = Enum.Font.SourceSans
	speedLabel.TextSize = SPEED_TEXT_SIZE
	speedLabel.TextScaled = true
	speedLabel.TextColor3 = COLOR_WHITE
	speedLabel.TextStrokeTransparency = 0.75
	speedLabel.Text = "Vel: 0"
	speedLabel.Parent = container

	guiByPlayer[player] = {
		container = container;
		nameLabel = nameLabel;
		speedLabel = speedLabel;
		lastVehicle = nil;
		lastSeat = nil;
		speedSource = nil;
		visible = true;
		debugShown = false;
	}
	return guiByPlayer[player]
end

local function removeGuiForPlayer(player)
	local data = guiByPlayer[player]
	if data then
		if data.container and data.container.Parent then
			pcall(function() data.container:Destroy() end)
		end
		guiByPlayer[player] = nil
	end
end

-- Determina se player está dirigindo; retorna boolean, seat
local function isPlayerDriving(player)
	if not player then return false end
	local char = player.Character
	if not char then return false end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	local seat = humanoid.SeatPart
	if not seat then return false end
	if not seat:IsA("VehicleSeat") then return false end
	if seat.Occupant ~= humanoid then return false end
	return true, seat
end

-- Tenta obter velocidade definida no veículo (NumberValue ou Attribute) -> retorna number or nil and debug string
local function getVehicleDefinedSpeed(data)
	if not data then return nil, nil end
	-- usar cache se válido
	if data.speedSource then
		local c = data.speedSource
		if c.type == "NumberValue" and c.obj and c.obj.Parent then
			return c.obj.Value, ("NumberValue:%s"):format(c.obj.Name)
		elseif c.type == "Attribute" and data.lastVehicle and data.lastVehicle:GetAttribute(c.key) ~= nil then
			return data.lastVehicle:GetAttribute(c.key), ("Attribute:%s"):format(c.key)
		end
		data.speedSource = nil
	end

	local vehicle = data.lastVehicle
	local seat = data.lastSeat
	if vehicle then
		local nv = findNumberValueSpeed(vehicle)
		if nv then
			data.speedSource = { type = "NumberValue", obj = nv }
			return nv.Value, ("NumberValue:%s"):format(nv.Name)
		end
		local key, val = findAttributeSpeed(vehicle)
		if key then
			data.speedSource = { type = "Attribute", key = key }
			return val, ("Attribute:%s"):format(key)
		end
	end
	if seat then
		for _,c in ipairs(seat:GetChildren()) do
			if c:IsA("NumberValue") and string.find(c.Name:lower(), "speed") then
				data.speedSource = { type = "NumberValue", obj = c }
				return c.Value, ("SeatNumberValue:%s"):format(c.Name)
			end
		end
		if seat.GetAttributes then
			for k,v in pairs(seat:GetAttributes()) do
				if type(v) == "number" and string.find(k:lower(), "speed") then
					data.speedSource = { type = "Attribute", key = k }
					return v, ("SeatAttribute:%s"):format(k)
				end
			end
		end
	end
	return nil, nil
end

-- Atualiza quais GUIs devem existir (cria apenas para drivers)
local refreshTimer = 0
local function refresh()
	for _,player in ipairs(Players:GetPlayers()) do
		local ok, seatOrErr = pcall(isPlayerDriving, player)
		if ok and seatOrErr then
			-- está dirigindo
			local seat = seatOrErr
			-- cria GUI se não existir
			local guiData = create2DGuiForPlayer(player)
			if guiData then
				-- atualizar referências de seat/vehicle
				local vehicle = getVehicleFromSeat(seat)
				if guiData.lastSeat ~= seat then
					guiData.lastSeat = seat
					guiData.lastVehicle = vehicle
					guiData.speedSource = nil
					guiData.visible = true
					guiData.debugShown = false
				end
			end
		else
			-- remover se existir
			if guiByPlayer[player] then removeGuiForPlayer(player) end
		end
	end
end

-- Atualiza posições e textos (cada frame)
local function update(dt)
	if not Camera then Camera = Workspace.CurrentCamera end
	for player, data in pairs(guiByPlayer) do
		-- validar player e character
		if not player or not data or not data.container then
			removeGuiForPlayer(player)
		else
			-- posição de referência: seat position ou HRP
			local refPos = nil
			if data.lastSeat and data.lastSeat.Parent then
				refPos = data.lastSeat.Position + OFFSET_WORLD
			else
				-- tenta recompor a partir do character
				if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					refPos = player.Character.HumanoidRootPart.Position + OFFSET_WORLD
				end
			end

			if not refPos then
				data.container.Visible = false
			else
				-- verifica distância da câmera
				local camPos = Camera.CFrame.Position
				if (refPos - camPos).Magnitude > MAX_VIEW_DISTANCE then
					data.container.Visible = false
				else
					-- transforma para viewport
					local onScreen, screenPos = pcall(function()
						return Camera:WorldToViewportPoint(refPos)
					end)
					if onScreen then
						-- WorldToViewportPoint devolve (x,y,z) e um boolean no 3rd? usamos padrão: returns Vector3 and boolean as third return in some contexts; safe approach:
						local sx, sy, depth
						if typeof(screenPos) == "Vector3" then
							-- pcall returned only the Vector3
							sx = screenPos.X; sy = screenPos.Y; depth = screenPos.Z
						else
							-- compatibility: Camera:WorldToViewportPoint returns (Vector3) in Luau in most cases
							sx = screenPos.X; sy = screenPos.Y; depth = screenPos.Z
						end
						if depth and depth > 0 then
							data.container.Visible = data.visible
							-- posiciona o container centralizado
							local w = data.container.AbsoluteSize.X
							local h = data.container.AbsoluteSize.Y
							-- Como AbsoluteSize pode ser zero no primeiro frame, usamos offsets via UDim2
							data.container.Position = UDim2.new(0, sx - 100, 0, sy - 22)
						else
							data.container.Visible = false
						end
					else
						data.container.Visible = false
					end
				end
			end

			-- Atualiza velocidade
			local displayed = 0
			local sourceDesc = nil
			local ok, vehSpeed = pcall(getVehicleDefinedSpeed, data)
			if ok and type(vehSpeed) == "number" then
				displayed = math.floor(vehSpeed + 0.5)
				sourceDesc = "vehicleValue"
			else
				-- fallback seat/HRP velocity
				local speedVal = 0
				if data.lastSeat and data.lastSeat:IsA("BasePart") then
					local vel = data.lastSeat.AssemblyLinearVelocity or data.lastSeat.Velocity or Vector3.new()
					speedVal = vel.Magnitude
				else
					if player.Character then
						local hrp = player.Character:FindFirstChild("HumanoidRootPart") or player.Character:FindFirstChild("Torso")
						if hrp then
							local vel = hrp.AssemblyLinearVelocity or hrp.Velocity or Vector3.new()
							speedVal = vel.Magnitude
						end
					end
				end
				displayed = math.floor(speedVal + 0.5)
				sourceDesc = "physical"
			end

			-- Atualiza texto com cores
			if displayed >= 1 and displayed <= 100 then
				data.speedLabel.TextColor3 = COLOR_GREEN
				data.speedLabel.Text = "Vel: " .. tostring(displayed)
			elseif displayed >= 101 then
				data.speedLabel.TextColor3 = COLOR_RED
				data.speedLabel.Text = "Vel: " .. tostring(displayed) .. " ⚠️"
			else
				data.speedLabel.TextColor3 = COLOR_WHITE
				data.speedLabel.Text = "Vel: 0"
			end

			-- Debug: printa primeira vez qual fonte foi usada para esse veículo
			if not data.debugShown then
				local vehSource = nil
				if data.speedSource then
					if data.speedSource.type == "NumberValue" and data.speedSource.obj then
						vehSource = "NumberValue:" .. tostring(data.speedSource.obj.Name)
					elseif data.speedSource.type == "Attribute" then
						vehSource = "Attribute:" .. tostring(data.speedSource.key)
					end
				end
				print(("[SpeedHUD] %s -> fonte: %s (modo: %s)"):format(tostring(player.Name), tostring(vehSource or "nenhuma, usando físico"), sourceDesc or "unknown"))
				data.debugShown = true
			end
		end
	end
end

-- Inicialização e loop
RunService.RenderStepped:Connect(function(dt)
	if not enabled then return end
	-- refresh ocasional
	refreshTimer = refreshTimer + dt
	if refreshTimer >= REFRESH_INTERVAL then
		refreshTimer = 0
		pcall(refresh)
	end
	-- update constante
	if UPDATE_GUI_EVERY_FRAME then
		pcall(update, dt)
	end
end)

-- Remove GUIs ao sair
Players.PlayerRemoving:Connect(function(p)
	removeGuiForPlayer(p)
end)

-- Primeira chamada imediata
pcall(refresh)

print("[SpeedHUD] script carregado. Parent GUI:", parentSource)
if not screenGui then
	warn("[SpeedHUD] ScreenGui não foi criado. Verifique permissões do executor.")
end
