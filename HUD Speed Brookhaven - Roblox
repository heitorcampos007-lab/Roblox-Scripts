-- LocalScript: Speed HUD (mostra a velocidade CONFIGURADA no veículo)
-- Coloque em: StarterPlayer > StarterPlayerScripts
-- O script mostrará, para O SEU CLIENTE, um BillboardGui acima de cada jogador
-- que estiver sentado em um VehicleSeat (motorista ou passageiro).
-- Exibe:
--   Linha 1: nick (branco)
--   Linha 2: Vel: (branco) <numero> (cor: 1-100 verde, 101+ vermelho + ⚠️)
-- A velocidade exibida é o VALOR DEFINIDO no veículo (NumberValue / IntValue / StringValue
-- convertível ou Attribute com nome contendo "speed"/"vel"). Se não houver campo acessível,
-- o valor exibido será 0.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Config
local MAX_DISTANCE = 300
local STUDS_OFFSET = Vector3.new(0, 3.2, 0)
local CHECK_INTERVAL = 0.6 -- checa quem está sentado a cada X segundos

local SPEED_KEYWORDS = { "speed", "vel", "velocity", "velocidade" }
local PRIORITY_NAMES = { "Speed","MaxSpeed","VehicleSpeed","CarSpeed","TopSpeed","MaxVelocity","SpeedValue","DriveSpeed" }

local COLOR_WHITE = Color3.fromRGB(255,255,255)
local COLOR_GREEN = Color3.fromRGB(76,175,80)
local COLOR_RED   = Color3.fromRGB(244,67,54)

-- Estado
local billboards = {}  -- jogador -> { billboard, nameLabel, speedLabel, seat, vehicle, sourceCache }
local vehicleCache = {} -- vehicleModel -> { source = { type="Child"/"Attribute"/"SeatAttr", obj/key=... } }

-- Utilities

local function isPlayerSeated(player)
	-- retorna true, seatPart se o jogador estiver sentado (motorista ou passageiro)
	if not player or not player.Character then return false end
	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	local seat = humanoid.SeatPart
	if not seat then return false end
	if not seat:IsA("VehicleSeat") then return false end
	-- Se SeatPart existir e for VehicleSeat, consideramos sentado (inclui motorista e passageiros)
	return true, seat
end

local function getVehicleFromSeat(seat)
	if not seat then return nil end
	local node = seat
	while node and node ~= Workspace do
		if node:IsA("Model") then return node end
		node = node.Parent
	end
	return nil
end

-- Procura valores numéricos (NumberValue/IntValue/StringValue) com prioridades e keywords
local function findNumericChild(model)
	if not model then return nil end
	-- Priorizar nomes conhecidos
	for _,name in ipairs(PRIORITY_NAMES) do
		local ok, found = pcall(function() return model:FindFirstChild(name, true) end)
		if ok and found and (found:IsA("NumberValue") or found:IsA("IntValue") or found:IsA("StringValue")) then
			return found
		end
	end
	-- Buscar por descendentes contendo keywords
	for _,desc in ipairs(model:GetDescendants()) do
		if desc:IsA("NumberValue") or desc:IsA("IntValue") or desc:IsA("StringValue") then
			local lname = desc.Name:lower()
			for _,k in ipairs(SPEED_KEYWORDS) do
				if string.find(lname, k) then
					return desc
				end
			end
		end
	end
	return nil
end

-- Procura atributo numérico no model com keyword no nome
local function findAttributeKey(model)
	if not model or type(model.GetAttributes) ~= "function" then return nil end
	for k,v in pairs(model:GetAttributes()) do
		if type(v) == "number" then
			local lk = k:lower()
			for _,kw in ipairs(SPEED_KEYWORDS) do
				if string.find(lk, kw) then
					return k
				end
			end
		end
	end
	return nil
end

-- Monitoramento simples: tenta detectar a "fonte" de velocidade para um veículo e cacheá-la
local function monitorVehicle(vehicle)
	if not vehicle or not vehicle.Parent then return nil end
	if vehicleCache[vehicle] then return vehicleCache[vehicle] end

	local entry = { source = nil, conns = {} }
	vehicleCache[vehicle] = entry

	local function tryDetect()
		-- procura child
		local c = findNumericChild(vehicle)
		if c then
			entry.source = { type = "Child", obj = c }
			return
		end
		-- procura atributo
		local attrKey = findAttributeKey(vehicle)
		if attrKey then
			entry.source = { type = "Attribute", key = attrKey }
			return
		end
		-- procurar no seat específico (caso o vehicle model não contenha diretamente)
		for _,desc in ipairs(vehicle:GetDescendants()) do
			if desc:IsA("VehicleSeat") then
				-- children do seat
				for _,ch in ipairs(desc:GetChildren()) do
					if (ch:IsA("NumberValue") or ch:IsA("IntValue") or ch:IsA("StringValue")) then
						local ln = ch.Name:lower()
						for _,kw in ipairs(SPEED_KEYWORDS) do
							if string.find(ln, kw) then
								entry.source = { type = "Child", obj = ch }
								return
							end
						end
					end
				end
				-- atributos do seat
				if type(desc.GetAttributes) == "function" then
					for k,v in pairs(desc:GetAttributes()) do
						if type(v) == "number" then
							local lk = k:lower()
							for _,kw in ipairs(SPEED_KEYWORDS) do
								if string.find(lk, kw) then
									entry.source = { type = "SeatAttr", key = k, seat = desc }
									return
								end
							end
						end
					end
				end
			end
		end
		entry.source = nil
	end

	-- conectar DescendantAdded para tentar detectar se painel cria valores após spawn
	local ok, conn = pcall(function()
		return vehicle.DescendantAdded:Connect(function(desc)
			if desc:IsA("NumberValue") or desc:IsA("IntValue") or desc:IsA("StringValue") then
				local name = desc.Name:lower()
				for _,kw in ipairs(SPEED_KEYWORDS) do
					if string.find(name, kw) then
						-- pequeno delay para dar tempo do valor ser setado
						task.delay(0.05, tryDetect)
						return
					end
				end
			end
		end)
	end)
	if ok and conn then table.insert(entry.conns, conn) end

	-- conectar mudanças de atributo no model (se suportado)
	if type(vehicle.GetAttributeChangedSignal) == "function" then
		local sOK, aconn = pcall(function()
			return vehicle:GetAttributeChangedSignal():Connect(function(attr)
				for _,kw in ipairs(SPEED_KEYWORDS) do
					if string.find(attr:lower(), kw) then
						pcall(tryDetect)
						return
					end
				end
			end)
		end)
		if sOK and aconn then table.insert(entry.conns, aconn) end
	end

	tryDetect()
	return entry
end

local function cleanupVehicle(vehicle)
	local e = vehicleCache[vehicle]
	if not e then return end
	for _,c in ipairs(e.conns) do
		pcall(function() c:Disconnect() end)
	end
	vehicleCache[vehicle] = nil
end

-- Cria BillboardGui para um jogador
local function createBillboard(player)
	if billboards[player] and billboards[player].billboard and billboards[player].billboard.Parent then
		return billboards[player]
	end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "SpeedHUD_" .. tostring(player.UserId or player.Name)
	billboard.Size = UDim2.new(0, 160, 0, 44)
	billboard.StudsOffset = STUDS_OFFSET
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = MAX_DISTANCE
	billboard.Parent = PlayerGui

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "Name"
	nameLabel.Size = UDim2.new(1, -6, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 3, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextSize = 18
	nameLabel.TextScaled = true
	nameLabel.TextColor3 = COLOR_WHITE
	nameLabel.TextStrokeTransparency = 0.7
	nameLabel.Text = player.DisplayName or player.Name
	nameLabel.Parent = billboard

	local speedLabel = Instance.new("TextLabel")
	speedLabel.Name = "Speed"
	speedLabel.Size = UDim2.new(1, -6, 0.5, 0)
	speedLabel.Position = UDim2.new(0, 3, 0.5, 0)
	speedLabel.BackgroundTransparency = 1
	speedLabel.Font = Enum.Font.SourceSans
	speedLabel.TextSize = 18
	speedLabel.TextScaled = true
	speedLabel.TextColor3 = COLOR_WHITE
	speedLabel.TextStrokeTransparency = 0.7
	speedLabel.Text = "Vel: 0"
	speedLabel.Parent = billboard

	billboards[player] = {
		billboard = billboard;
		nameLabel = nameLabel;
		speedLabel = speedLabel;
		seat = nil;
		vehicle = nil;
		sourceCache = nil;
	}

	return billboards[player]
end

local function removeBillboard(player)
	local d = billboards[player]
	if not d then return end
	if d.billboard and d.billboard.Parent then
		pcall(function() d.billboard:Destroy() end)
	end
	billboards[player] = nil
end

-- Obtém o valor configurado no veículo (se disponível). Retorna number or nil.
local function getVehicleConfiguredSpeed(d)
	if not d or not d.vehicle then return nil end
	local vEntry = vehicleCache[d.vehicle]
	if vEntry and vEntry.source then
		local s = vEntry.source
		if s.type == "Child" and s.obj and s.obj.Parent then
			local obj = s.obj
			if obj:IsA("NumberValue") or obj:IsA("IntValue") then
				return tonumber(obj.Value)
			elseif obj:IsA("StringValue") then
				return tonumber(obj.Value)
			end
		elseif s.type == "Attribute" and d.vehicle:GetAttribute(s.key) ~= nil then
			return tonumber(d.vehicle:GetAttribute(s.key))
		elseif s.type == "SeatAttr" and s.seat and s.seat:GetAttribute(s.key) ~= nil then
			return tonumber(s.seat:GetAttribute(s.key))
		end
	end

	-- tentativa rápida direta (caso monitorVehicle não tenha detectado)
	local direct = findNumericChild(d.vehicle)
	if direct then
		if direct:IsA("StringValue") then return tonumber(direct.Value) end
		return tonumber(direct.Value)
	end

	return nil
end

-- Atualiza o texto do GUI para um jogador
local function updateGui(player, d)
	if not d or not d.billboard then return end
	-- name já definido; only update speed part
	local val = getVehicleConfiguredSpeed(d)
	local displayed = tonumber(val) or 0

	-- montar string com cores
	-- Nome e "Vel:" ficam brancos; o número recebe cor conforme regra.
	local textNumber = tostring(displayed)
	if displayed >= 1 and displayed <= 100 then
		d.speedLabel.TextColor3 = COLOR_GREEN
		d.speedLabel.Text = "Vel: " .. textNumber
	elseif displayed >= 101 then
		d.speedLabel.TextColor3 = COLOR_RED
		d.speedLabel.Text = "Vel: " .. textNumber .. " ⚠️"
	else
		d.speedLabel.TextColor3 = COLOR_WHITE
		d.speedLabel.Text = "Vel: 0"
	end
end

-- Atualiza adornee (onde a billboard fica presa) e referências vehicle/seat
local function setAdorneeForPlayer(player, d, seat)
	if not d or not d.billboard then return end
	d.seat = seat
	-- preferir prender ao seat (mostra acima do carro); se não houver, prender no HRP
	if seat and seat.Parent then
		d.billboard.Adornee = seat
		d.vehicle = getVehicleFromSeat(seat)
	else
		d.billboard.Adornee = nil
		if player.Character then
			local hrp = player.Character:FindFirstChild("HumanoidRootPart") or player.Character:FindFirstChild("Torso")
			if hrp then
				d.billboard.Adornee = hrp
				d.vehicle = nil
			end
		end
	end
	-- monitorar vehicle se existir
	if d.vehicle then monitorVehicle(d.vehicle) end
end

-- Periodicamente cria/removes billboards conforme jogadores sentados
local refreshTimer = 0
local function refreshAllPlayers()
	for _,player in ipairs(Players:GetPlayers()) do
		local ok, seat = pcall(isPlayerSeated, player)
		if ok and seat then
			local d = createBillboard(player)
			if d then
				setAdorneeForPlayer(player, d, seat)
				d.billboard.Enabled = true
			end
		else
			-- não sentado -> remover
			if billboards[player] then removeBillboard(player) end
		end
	end

	-- limpar vehicleCache de modelos removidos
	for veh,_ in pairs(vehicleCache) do
		if not veh.Parent then cleanupVehicle(veh) end
	end
end

-- Loop principal: check periodic + update every frame (but only update display if player has GUI)
RunService.RenderStepped:Connect(function(dt)
	refreshTimer = refreshTimer + dt
	if refreshTimer >= CHECK_INTERVAL then
		refreshTimer = 0
		pcall(refreshAllPlayers)
	end

	-- atualiza todos os guis existentes (apenas mostra valor que foi colocado no veículo)
	for pl, d in pairs(billboards) do
		pcall(updateGui, pl, d)
	end
end)

-- Clean-up ao sair
Players.PlayerRemoving:Connect(function(p)
	if billboards[p] then removeBillboard(p) end
end)

-- Inicial
-- primeira varredura imediata
pcall(refreshAllPlayers)
print("[SpeedHUD] carregado: mostrando velocidade configurada nos veículos (se acessível).")
