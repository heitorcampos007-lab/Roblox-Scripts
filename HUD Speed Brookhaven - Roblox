-- SpeedHUD Delta v4
-- Versão com debug/ativação imediata: quando você clicar ON o script fará varredura e tentará criar os HUDs,
-- imprimindo no console por que cada jogador não teve HUD criado (se houver problema).
-- Execute via executor (Delta) dentro do jogo.

-- ========== CONFIG ==========
local REFRESH_INTERVAL = 0.6
local OFFSET_STUDS = Vector3.new(0, 3.6, 0)
local PRIORITY_NAMES = { "Speed","MaxSpeed","VehicleSpeed","CarSpeed","TopSpeed","MaxVelocity","SpeedValue","DriveSpeed" }
local SPEED_KEYWORDS = { "speed", "vel", "velocity", "velocidade" }
local COLOR_GREEN = Color3.fromRGB(76,175,80)
local COLOR_RED   = Color3.fromRGB(244,67,54)
local COLOR_WHITE = Color3.fromRGB(255,255,255)
-- ===========================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then repeat Players.PlayerAdded:Wait() until Players.LocalPlayer; LocalPlayer = Players.LocalPlayer end

-- executor helpers
local gethui_f = (type(gethui) == "function") and gethui
if not gethui_f and type(syn) == "table" and type(syn.get_hui) == "function" then gethui_f = syn.get_hui end
local protect_gui_f = (type(syn) == "table" and type(syn.protect_gui) == "function") and syn.protect_gui
if not protect_gui_f and type(protect_gui) == "function" then protect_gui_f = protect_gui end

local function chooseGuiParent()
	local pg = LocalPlayer:FindFirstChild("PlayerGui")
	if pg and pg.Parent then return pg, "PlayerGui" end
	if gethui_f then
		local ok, gui = pcall(gethui_f)
		if ok and gui then return gui, "gethui()" end
	end
	local ok, cg = pcall(function() return game:GetService("CoreGui") end)
	if ok and cg then return cg, "CoreGui" end
	return nil, "none"
end

local GuiParent, parentSource = chooseGuiParent()
print("[SpeedHUD] GUI parent:", parentSource)
if protect_gui_f and GuiParent then pcall(function() protect_gui_f(GuiParent) end); print("[SpeedHUD] protect_gui aplicado") end
if not GuiParent then warn("[SpeedHUD] Nenhum GuiParent disponível. Executor pode bloquear GUIs.") end

-- estado
local enabled = false -- começa OFF
local guiByPlayer = {}
local vehicleData = {}

-- utilitárias
local function isPlayerDriving(player)
	if not player or not player.Character then return false end
	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	local seat = humanoid.SeatPart
	if not seat then return false end
	if not seat:IsA("VehicleSeat") then return false end
	if seat.Occupant ~= humanoid then return false end
	return true, seat
end

local function getVehicleFromSeat(seat)
	if not seat then return nil end
	local node = seat
	while node and node ~= Workspace do
		if node:IsA("Model") then return node end
		node = node.Parent
	end
	return nil
end

local function findNumericChildInModel(model)
	if not model then return nil end
	for _,name in ipairs(PRIORITY_NAMES) do
		local ok, v = pcall(function() return model:FindFirstChild(name, true) end)
		if ok and v and (v:IsA("NumberValue") or v:IsA("IntValue") or v:IsA("StringValue")) then return v end
	end
	for _,desc in ipairs(model:GetDescendants()) do
		if desc:IsA("NumberValue") or desc:IsA("IntValue") or desc:IsA("StringValue") then
			local lname = desc.Name:lower()
			for _,k in ipairs(SPEED_KEYWORDS) do
				if string.find(lname, k) then return desc end
			end
		end
	end
	return nil
end

local function findAttributeKey(model)
	if not model or type(model.GetAttributes) ~= "function" then return nil end
	for k,v in pairs(model:GetAttributes()) do
		if type(v) == "number" then
			local lk = k:lower()
			for _,key in ipairs(SPEED_KEYWORDS) do
				if string.find(lk, key) then return k end
			end
		end
	end
	return nil
end

-- monitorVehicle (detecta child/attribute e conecta DescendantAdded / AttributeChanged)
local function monitorVehicle(vehicle)
	if not vehicle or not vehicle.Parent then return end
	if vehicleData[vehicle] then return vehicleData[vehicle] end
	local data = { source = nil, connections = {}, printedSourceInfo = false }
	vehicleData[vehicle] = data

	local function tryDetect()
		local found = findNumericChildInModel(vehicle)
		if found then data.source = { type = "ChildValue", obj = found }; data.lastFound = found; return end
		local key = findAttributeKey(vehicle)
		if key then data.source = { type = "Attribute", key = key }; return end
		-- verificar seats internos
		for _,seat in ipairs(vehicle:GetDescendants()) do
			if seat:IsA("VehicleSeat") then
				for _,c in ipairs(seat:GetChildren()) do
					if (c:IsA("NumberValue") or c:IsA("IntValue") or c:IsA("StringValue")) then
						local ln = c.Name:lower()
						for _,k in ipairs(SPEED_KEYWORDS) do
							if string.find(ln, k) then data.source = { type="ChildValue", obj=c }; data.lastFound=c; return end
						end
					end
				end
				if type(seat.GetAttributes) == "function" then
					for k,v in pairs(seat:GetAttributes()) do
						if type(v) == "number" then
							local lk = k:lower()
							for _,kw in ipairs(SPEED_KEYWORDS) do
								if string.find(lk, kw) then data.source = { type="SeatAttribute", key=k, seat=seat }; return end
							end
						end
					end
				end
			end
		end
		data.source = nil
	end

	local ok1, conn1 = pcall(function()
		return vehicle.DescendantAdded:Connect(function(desc)
			if desc:IsA("NumberValue") or desc:IsA("IntValue") or desc:IsA("StringValue") then
				local lname = desc.Name:lower()
				for _,k in ipairs(SPEED_KEYWORDS) do
					if string.find(lname, k) then wait(0.05); tryDetect(); return end
				end
			end
		end)
	end)
	if ok1 and conn1 then table.insert(data.connections, conn1) end

	if type(vehicle.GetAttributeChangedSignal) == "function" then
		local ok2, conn2 = pcall(function()
			return vehicle:GetAttributeChangedSignal():Connect(function(attr)
				local lk = attr:lower()
				for _,k in ipairs(SPEED_KEYWORDS) do if string.find(lk, k) then pcall(tryDetect) end end
			end)
		end)
		if ok2 and conn2 then table.insert(data.connections, conn2) end
	end

	tryDetect()
	return data
end

local function cleanupVehicle(vehicle)
	local d = vehicleData[vehicle]
	if not d then return end
	for _,c in ipairs(d.connections) do pcall(function() c:Disconnect() end) end
	vehicleData[vehicle] = nil
end

-- cria billboard
local function createBillboardForPlayer(player, seat)
	if not GuiParent then return nil, "GuiParent nil" end
	if guiByPlayer[player] and guiByPlayer[player].billboard and guiByPlayer[player].billboard.Parent then
		local g = guiByPlayer[player]; g.billboard.Adornee = seat or g.billboard.Adornee; return g, "reused"
	end

	local ok, b = pcall(function()
		local bb = Instance.new("BillboardGui")
		bb.Name = "SpeedHUD_" .. tostring(player.UserId or player.Name)
		bb.Size = UDim2.new(0,180,0,44)
		bb.StudsOffset = OFFSET_STUDS
		bb.AlwaysOnTop = true
		bb.MaxDistance = 350
		bb.Adornee = seat
		bb.Parent = GuiParent
		return bb
	end)
	if not ok or not b then return nil, ("failed_create:"..tostring(b)) end

	local nameLabel = Instance.new("TextLabel")
	nameLabel.BackgroundTransparency = 1
	nameLabel.Size = UDim2.new(1,-6,0.5,0)
	nameLabel.Position = UDim2.new(0,3,0,0)
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextSize = 18; nameLabel.TextScaled = true
	nameLabel.TextColor3 = COLOR_WHITE; nameLabel.TextStrokeTransparency = 0.7
	nameLabel.Text = player.DisplayName or player.Name
	nameLabel.Parent = b

	local speedLabel = Instance.new("TextLabel")
	speedLabel.BackgroundTransparency = 1
	speedLabel.Size = UDim2.new(1,-6,0.5,0)
	speedLabel.Position = UDim2.new(0,3,0.5,0)
	speedLabel.Font = Enum.Font.SourceSans
	speedLabel.TextSize = 18; speedLabel.TextScaled = true
	speedLabel.TextColor3 = COLOR_WHITE; speedLabel.TextStrokeTransparency = 0.7
	speedLabel.Text = "Vel: 0"
	speedLabel.Parent = b

	guiByPlayer[player] = { billboard = b; nameLabel = nameLabel; speedLabel = speedLabel; seat = seat; vehicle = seat and getVehicleFromSeat(seat) or nil; visible = true }
	if guiByPlayer[player].vehicle then monitorVehicle(guiByPlayer[player].vehicle) end
	return guiByPlayer[player], "created"
end

local function removeBillboardForPlayer(player)
	local d = guiByPlayer[player]
	if not d then return end
	if d.billboard and d.billboard.Parent then pcall(function() d.billboard:Destroy() end) end
	guiByPlayer[player] = nil
end

local function getVehicleDefinedSpeed(d)
	if not d or not d.vehicle then return nil, nil end
	local vd = vehicleData[d.vehicle]
	if vd and vd.source then
		local s = vd.source
		if s.type == "ChildValue" and s.obj and s.obj.Parent then
			if s.obj:IsA("NumberValue") or s.obj:IsA("IntValue") then return tonumber(s.obj.Value), ("Child:%s"):format(s.obj:GetFullName()) end
			if s.obj:IsA("StringValue") then local n = tonumber(s.obj.Value); if n then return n, ("ChildStr:%s"):format(s.obj:GetFullName()) end end
		elseif s.type == "Attribute" and d.vehicle:GetAttribute(s.key) ~= nil then
			return d.vehicle:GetAttribute(s.key), ("Attribute:%s"):format(s.key)
		elseif s.type == "SeatAttribute" and s.seat and s.seat:GetAttribute(s.key) ~= nil then
			return s.seat:GetAttribute(s.key), ("SeatAttribute:%s"):format(s.key)
		end
	end
	-- fallback quick search
	local direct = findNumericChildInModel(d.vehicle) or (d.seat and (function()
		for _,c in ipairs(d.seat:GetChildren()) do
			if (c:IsA("NumberValue") or c:IsA("IntValue") or c:IsA("StringValue")) then
				local ln = c.Name:lower()
				for _,k in ipairs(SPEED_KEYWORDS) do if string.find(ln, k) then if c:IsA("StringValue") then local n = tonumber(c.Value); if n then return c end else return c end end end
			end
		end
		return nil
	end)())
	if direct then
		if direct:IsA("StringValue") then local n = tonumber(direct.Value); if n then return n, ("DirectStr:%s"):format(direct:GetFullName()) end
		else return tonumber(direct.Value), ("DirectChild:%s"):format(direct:GetFullName()) end
	end
	return nil, nil
end

local function getPhysicalSpeedForSeat(seat)
	if not seat then return 0 end
	local vel = seat.AssemblyLinearVelocity or seat.Velocity or Vector3.new()
	return math.floor(vel.Magnitude + 0.5)
end

local function updateGuiForPlayer(player, d)
	if not d or not d.billboard then return end
	local displayed = 0
	local ok, vehVal, desc = pcall(function() return getVehicleDefinedSpeed(d) end)
	if ok and vehVal and type(vehVal) == "number" then displayed = math.floor(vehVal + 0.5) else displayed = getPhysicalSpeedForSeat(d.seat) end
	if displayed >= 1 and displayed <= 100 then d.speedLabel.TextColor3 = COLOR_GREEN; d.speedLabel.Text = "Vel: " .. tostring(displayed)
	elseif displayed >= 101 then d.speedLabel.TextColor3 = COLOR_RED; d.speedLabel.Text = "Vel: " .. tostring(displayed) .. " ⚠️"
	else d.speedLabel.TextColor3 = COLOR_WHITE; d.speedLabel.Text = "Vel: 0" end

	-- debug print uma vez por vehicle
	if d.vehicle and vehicleData[d.vehicle] and not vehicleData[d.vehicle].printedSourceInfo then
		local vd = vehicleData[d.vehicle]; vehicleData[d.vehicle].printedSourceInfo = true
		if vd.source then print(("[SpeedHUD] Fonte do veículo %s: %s"):format(d.vehicle:GetFullName(), tostring(vd.source.type == "ChildValue" and vd.source.obj:GetFullName() or (vd.source.key or "unknown"))))
		else print(("[SpeedHUD] Veículo %s: nenhuma fonte detectada (usando físico)"):format(d.vehicle:GetFullName())) end
	end
end

local function ensureRefsForPlayer(player, d, seat)
	if not d then return end
	d.seat = seat
	d.billboard.Adornee = seat
	d.vehicle = seat and getVehicleFromSeat(seat) or nil
	if d.vehicle then monitorVehicle(d.vehicle) end
end

-- Refresh drivers (cria/destroi) - chamada periódica
local function refreshDrivers()
	for _,pl in ipairs(Players:GetPlayers()) do
		local ok, seat = pcall(isPlayerDriving, pl)
		if ok and seat then
			local d, reason = createBillboardForPlayer(pl, seat)
			if d then ensureRefsForPlayer(pl, d, seat); if d.billboard then d.billboard.Enabled = enabled end end
		else
			if guiByPlayer[pl] then removeBillboardForPlayer(pl) end
		end
	end
	for veh,vd in pairs(vehicleData) do if not veh.Parent then cleanupVehicle(veh) end end
end

-- ATIVAÇÃO IMEDIATA: quando o usuário clica ON chamamos isso para debug
local function activateImmediate()
	print("[SpeedHUD] tentando ativar HUDs para todos os players...")
	if not GuiParent then warn("[SpeedHUD] GuiParent nil — HUDs não podem ser criados") end
	for _,pl in ipairs(Players:GetPlayers()) do
		local ok, seat = pcall(isPlayerDriving, pl)
		if ok and seat then
			local d, reason = createBillboardForPlayer(pl, seat)
			if d then
				ensureRefsForPlayer(pl, d, seat)
				if d.billboard then d.billboard.Enabled = true end
				print(("[SpeedHUD] HUD criado para %s (seat: %s) -> %s"):format(pl.Name, tostring(seat:GetFullName()), tostring(reason)))
			else
				print(("[SpeedHUD] Não foi possível criar HUD para %s (reason: %s)"):format(pl.Name, tostring(reason)))
			end
		else
			print(("[SpeedHUD] %s não está dirigindo (ou erro: %s)"):format(pl.Name, tostring(seat)))
			-- removemos caso exista por segurança
			if guiByPlayer[pl] then removeBillboardForPlayer(pl) end
		end
	end
end

-- loop principal
local refreshTimer = 0
RunService.RenderStepped:Connect(function(dt)
	refreshTimer = refreshTimer + dt
	if refreshTimer >= REFRESH_INTERVAL then refreshTimer = 0; pcall(refreshDrivers) end
	if not enabled then return end
	for pl,d in pairs(guiByPlayer) do pcall(updateGuiForPlayer, pl, d) end
end)

Players.PlayerRemoving:Connect(function(p) removeBillboardForPlayer(p) end)

-- Pequena notificação na tela
local function showNotification(text, timeSec)
	if not GuiParent then return end
	local ok, sg = pcall(function()
		local s = Instance.new("ScreenGui")
		s.Name = "SpeedHUD_Notice"
		s.ResetOnSpawn = false
		s.Parent = GuiParent
		return s
	end)
	if not ok or not sg then return end
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0,220,0,40)
	frame.Position = UDim2.new(0.5, -110, 0.05, 0)
	frame.BackgroundColor3 = Color3.fromRGB(25,25,25)
	frame.BackgroundTransparency = 0.2
	frame.BorderSizePixel = 0
	frame.Parent = sg
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1,0,1,0)
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.SourceSansBold
	label.TextSize = 18
	label.TextColor3 = Color3.fromRGB(255,255,255)
	label.Text = text
	label.Parent = frame
	spawn(function()
		wait(timeSec or 1.6)
		pcall(function() sg:Destroy() end)
	end)
end

-- Toggle draggável (corrigido) - usa TextButton e chama activateImmediate() quando ligado
local function createDraggableToggle()
	if not GuiParent then warn("[SpeedHUD] toggle: GuiParent nil"); return end
	local ok, sg = pcall(function()
		local s = Instance.new("ScreenGui")
		s.Name = "SpeedHUD_ToggleGui_v4"
		s.ResetOnSpawn = false
		s.Parent = GuiParent
		return s
	end)
	if not ok or not sg then warn("[SpeedHUD] Falha criar ScreenGui do toggle:", sg); return end

	local btn = Instance.new("TextButton")
	btn.Name = "SpeedToggle"
	btn.Size = UDim2.new(0, 64, 0, 64)
	btn.Position = UDim2.new(0.02, 0, 0.02, 0)
	btn.AnchorPoint = Vector2.new(0,0)
	btn.BackgroundColor3 = Color3.fromRGB(25,25,25)
	btn.BackgroundTransparency = 0.2
	btn.BorderSizePixel = 0
	btn.Font = Enum.Font.SourceSansBold
	btn.TextSize = 20
	btn.TextColor3 = Color3.fromRGB(255,255,255)
	btn.Text = "OFF"
	btn.Parent = sg
	btn.Active = true

	local dragging = false
	local dragInput = nil
	local dragStart = nil
	local startPos = nil
	local moved = false
	local touchStartTime = 0

	local function updatePosition(input)
		local delta = input.Position - dragStart
		btn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		moved = true
	end

	btn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = btn.Position
			dragInput = input
			moved = false
			touchStartTime = tick()
		end
	end)

	btn.InputChanged:Connect(function(input)
		if input == dragInput then updatePosition(input) end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then updatePosition(input) end
	end)

	btn.InputEnded:Connect(function(input)
		if input == dragInput then
			dragging = false
			dragInput = nil
			local duration = tick() - touchStartTime
			local wasTap = (not moved) and (duration < 0.35)
			if not wasTap and moved then
				local delta = (input.Position - dragStart).Magnitude
				if delta < 8 and duration < 0.35 then wasTap = true end
			end

			if wasTap then
				enabled = not enabled
				btn.Text = enabled and "ON" or "OFF"
				if enabled then
					showNotification("SpeedHUD: ON", 1.4)
					print("[SpeedHUD] ativado via toggle")
					pcall(refreshDrivers)
					activateImmediate()
				else
					showNotification("SpeedHUD: OFF", 1.2)
					print("[SpeedHUD] desativado via toggle")
					for _,d in pairs(guiByPlayer) do if d and d.billboard then d.billboard.Enabled = false end end
				end
			end

			-- clamp
			local screenX = GuiParent.AbsoluteSize and GuiParent.AbsoluteSize.X or 1920
			local screenY = GuiParent.AbsoluteSize and GuiParent.AbsoluteSize.Y or 1080
			local x = math.clamp(btn.Position.X.Offset, 0, math.max(0, screenX - btn.AbsoluteSize.X))
			local y = math.clamp(btn.Position.Y.Offset, 0, math.max(0, screenY - btn.AbsoluteSize.Y))
			btn.Position = UDim2.new(0, x, 0, y)
		end
	end)

	btn.Activated:Connect(function()
		-- Activated pode disparar em alguns casos; evita duplo toggle durante drag
		if dragging then return end
		enabled = not enabled
		btn.Text = enabled and "ON" or "OFF"
		if enabled then
			showNotification("SpeedHUD: ON", 1.4)
			print("[SpeedHUD] ativado via Activated")
			pcall(refreshDrivers)
			activateImmediate()
		else
			showNotification("SpeedHUD: OFF", 1.2)
			print("[SpeedHUD] desativado via Activated")
			for _,d in pairs(guiByPlayer) do if d and d.billboard then d.billboard.Enabled = false end end
		end
	end)
end

-- init
createDraggableToggle()
pcall(refreshDrivers)
print("[SpeedHUD] carregado (inicialmente OFF). Clique no botão para ligar.")
